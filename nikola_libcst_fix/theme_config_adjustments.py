import pathlib as pl
import libcst as cst
import difflib
import argparse
import os
import textwrap as tw
from nikola_libcst_fix.theme_visitor_subclasses import ThemeCollector,ThemeTransformer

here = pl.Path(__file__).resolve().parent
# input_dialogue is used in the theme_update function
input_dialogue = "Should we overwrite conf.py.backup with the modified ast?\n\t[Y]/n\n"
py_encoding = "UTF-8"


def theme_update(theme_conf_path:pl.Path or str,
                 base_conf_path:pl.Path or str,
                 should_overwrite_conf_silently:bool=False,
                 force_display_diff_report:bool=None)->None:
    """Parses a theme's conf.py.backup.sample file, along with the site's base conf.py.backup file, and updates the base file
    according to the fields found in the theme.

    Uses libCST (https://github.com/Instagram/LibCST)

    Follows the visitor/transformer idiom described in libCST's documentation to programatically read and modify the
    site's conf.py.backup file according to the contents of the theme's conf.py.backup.sample file.

    Modifications are performed in memory, then a diff report is generated and

    :param theme_conf_path: Absolute path to where the theme's config file
    :param base_conf_path: Absolute path to where the site's base config file can be found
    :param should_overwrite_conf_silently: A diagnostic flag that specifies if we should
    :param force_display_diff_report: A bool flag specifying if we should force the display of the diff report between
                                      the base conf.py.backup file and the code generated by the modified tree..
    :return: None
    """
    if isinstance(theme_conf_path,str):
        theme_conf_path = pl.Path(theme_conf_path).resolve()
    theme_name = theme_conf_path.parent.name
    # create the concrete syntax tree for the site's base conf.py.backup file
    with open(base_conf_path,'r',encoding=py_encoding) as f:
        base_tree = cst.parse_module(f.read())
    # create the concrete syntax tree for the theme's conf.py.backup.sample file
    with open(theme_conf_path, 'r', encoding=py_encoding) as f:
        theme_tree = cst.parse_module(f.read())
    # visitor will be used to create a mapping of the fields in the
    # theme config that should be modified in the base config.
    visitor = ThemeCollector(theme_name) # initializes the visitor
    # this is where the visitor traverses the theme tree and builds the member mapping.
    theme_tree.visit(visitor)
    # xfmr (shorthand for transformer) will take the mapping created by visitor
    # and apply changes to the base tree where it finds equivalent members/properties.
    xfmr = ThemeTransformer(visitor.replacement_targets)
    modified_base_tree = base_tree.visit(xfmr)
    # missed_nodes are the variables/functions/classes we found in the theme's conf.py.backup.sample file that had no analogue
    # in the conf.py.backup file. So, we'll just append them to the end of the conf.py.backup file here.
    #   Note: It could be a problem if these missed nodes need to be inserted in the order the appeared in the theme's
    #         config file, as libcst is still developing the tools for inserting nodes relative to a line number.
    #         * A possible solution is to somehow record the order nodes are encountered in the visitor, and then record
    #           the line number (or something like it) of updated fields in the visitor, then we can insert nodes at the
    #           appropriate position in the modified_base_tree.body list.
    missed_nodes = xfmr.all_keys.difference(xfmr.utlized_keys)
    if missed_nodes:
        code_strings = [modified_base_tree.code]
        for missing_k in missed_nodes:
            node:cst.CSTNode = xfmr.replacement_targets[missing_k]
            # this simply appends the missed nodes to the modified_base_tree and reparses the resulting code string.
            code_strings.append(modified_base_tree.code_for_node(node))
        if code_strings[-1] and not code_strings[-1].endswith("\n"):
            code_strings.append("")
        modified_base_tree = cst.parse_module("\n".join(code_strings))
    # libCST provides a built in recursive equality checking function, this lets us efficiently determine if the
    # modified_base_tree actually contains updates to the base_tree.
    if not modified_base_tree.deep_equals(base_tree):
        if force_display_diff_report or (force_display_diff_report is None and not should_overwrite_conf_silently):
            # for visual diagnostic inspection of the changes.
            diff = difflib.unified_diff(base_tree.code.splitlines(True),modified_base_tree.code.splitlines(True))
            difflog = "".join(diff)
            with open(base_conf_path.parent.joinpath("conf_modification_difflog.txt"),"w",encoding=py_encoding) as diff_f:
                diff_f.write(difflog)
            print(difflog)
        if should_overwrite_conf_silently or input(input_dialogue).lower()=='y':
            with open(base_conf_path,'w',encoding=py_encoding) as f:
                f.write(modified_base_tree.code)
        else:
            # creates a new file in the same directory as the original conf.py.backup file named 'modified_conf.py'
            with open(base_conf_path.parent.joinpath("modified_conf.py"),'w',encoding=py_encoding) as f:
                f.write(modified_base_tree.code)
    else:
        print(f"\n\nNo changes made to conf.py, likely due to one of the following reasons:"
              f"\n\n\t* It's possible that `<root>/themes/{theme_name}/conf.py.sample` was empty or contained only comments"
              "\n\n\t* It's also possible that the custom visitor/transformer classes need to be modified to capture the"
              "\n\t  grammar and syntax used in the theme's config file "
              "\n\t  Note: things like class definitions and update-assignment operators were not defined in the "
              "\n\t        visitors for this example"
              "\n\n\t* Or, the conf.py file is already updated for the chosen theme."
              )

theme_update_doc = theme_update.__doc__

def simple_demo():
    """Uses the example site directory structure include with this repository as a basic demonstration of how to use
     the libCST visitor patterns for updating a conf.py file to satisfy the needs of a Nikola hosted theme.
     
     This function sets up the path reference and theme name before passing those references to the theme_update func.

     See: @theme_update
     """
    safe_to_proceed = True
    root = here
    base_conf_py_path = root.joinpath("some_site_structure/conf.py").resolve()
    if not base_conf_py_path.exists():
        safe_to_proceed = False
        print("The example `conf.py.backup` file isn't where we expected it to be."
              "Please check the following path for where things might have gone wrong:"
              f"\n{str(base_conf_py_path)}"
              "\n\tThen modify the call to base_conf_py_path = root.joinpath('some_site_structure/conf.py').resolve()")
    else:
        # in order to allow the caller to make repeated calls and get the same output each time, we need to make sure
        # the conf.py file is in the same initial state each time.
        backup_path = root.joinpath("conf.py.backup")
        if not backup_path.exists():
            with open(backup_path,"w",encoding=py_encoding) as backup_f:
                backup_f.write(base_conf_py_path.read_text(py_encoding))
        backup_code = backup_path.read_text(py_encoding)
        if difflib.unified_diff(base_conf_py_path.read_text(py_encoding),backup_code):
            with open(base_conf_py_path,"w",encoding=py_encoding) as f:
                f.write(backup_code)
    theme_conf_py_path = root.joinpath("some_site_structure/themes/some_theme/conf.py.sample").resolve()
    if not theme_conf_py_path.exists():
        safe_to_proceed = False
        print("The example `conf.py.backup` file isn't where we expected it to be."
              "Please check the following path for where things might have gone wrong:"
              f"\n{str(base_conf_py_path)}"
              "\n\tThen modify the call to theme_conf_py_path = root.joinpath('some_site_structure/themes/some_theme/conf.py.sample').resolve()")
    if safe_to_proceed:
        theme_update(theme_conf_py_path,
                     base_conf_py_path)
    else:
        print("Until the path to the example config files is resolved, we can't run the example")

simple_demo.__doc__ += f"""
    
     theme_update::
     {theme_update_doc}
      """

def demo_from_terminal():
    parser = argparse.ArgumentParser("programmatic_config_editing")
    parser.add_argument("-t","--theme",
                        dest="theme",
                        default="canterville",
                        help="[OPTIONAL]Used to specify the name of the Nikola hosted theme we should use, with or without quotes."
                             "\n\t\tDefaults to using 'canterville'")
    parser.add_argument("-p","--path",default=os.getcwd(),
                        dest="root",
                        help="[OPTIONAL] Used to specify the absolute or relative path we should use to find the Nikola site's root directory; no need for quotes, even if there are space characters on the path."
                             f"\n\t\tDefaults to using `os.getcwd()`")
    parser.add_argument("-r","--reset_conf",default=False,dest="reset_conf",help="[OPTIONAL] Used to request that we reset conf.py to its pre-themed state."
                                                                                 "\n\t\tDefaults to `False`")
    args = parser.parse_args()
    name_of_theme = args.theme
    path_to_custom_site = args.root
    reset_conf = args.reset_conf
    demo(name_of_theme,path_to_custom_site,reset_conf)


def demo(name_of_theme:str,path_to_custom_site:str or pl.Path,reset_conf:bool):
    """An alternative invocation of the programmatic modification of config files using libCST.

     See: @theme_update
    
    :param name_of_theme: A string giving the name of the theme we should find the `conf.py.sample` file in.
    :param path_to_custom_site: A string or pl.Path object that defines the absolute, or relative, path to a Nikola
                                site's root folder.
    :param reset_conf: A bool specifying if we should reset the conf.py file to match it's saved backup
        (the backup is automatically generated and stored the first time this function runs)
    :return: None
    """
    root = pl.Path(path_to_custom_site).resolve()
    if not root.exists():
        raise FileNotFoundError("The given path to the site's root doesn't exist."
                                "Please check the following paths for where things might have gone wrong:"
                                f"\ngiven path_to_custom_site: {str(path_to_custom_site)}"
                                f"\nresolved path_to_custom_site: {str(root)}")
    else:
        cur_cwd = os.getcwd()
        os.chdir(root)
        print("root =",root)
        base_conf = root.joinpath("conf.py")
        if not base_conf.exists():
            raise FileNotFoundError("The given root path does not contain a `conf.py` file.",f"root: {root}")
        else:
            backup_conf = root.joinpath("conf.py.backup")
            if not backup_conf.exists():
                with open(backup_conf,"w",encoding=py_encoding) as backup_f:
                    backup_f.write(base_conf.read_text(py_encoding))
            elif reset_conf:
                with open(base_conf,"w",encoding=py_encoding) as base_f:
                    base_f.write(backup_conf.read_text(py_encoding))
            theme_conf = root.joinpath(f"themes/{name_of_theme}/conf.py.sample")
            if not theme_conf.exists():
                os.system(f"nikola theme -i {name_of_theme}")
            theme_update(theme_conf,base_conf)
        os.chdir(cur_cwd)

demo.__doc__ += f"""

    theme_update::    
    {theme_update_doc}"""

if __name__ == "__main__":
    simple_demo()