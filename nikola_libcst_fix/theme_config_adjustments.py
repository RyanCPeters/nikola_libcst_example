import pathlib as pl
import libcst as cst
import difflib
from nikola_libcst_fix.theme_visitor_subclasses import ThemeCollector,ThemeTransformer

here = pl.Path(__file__).resolve().parent
# input_dialogue is used in the theme_update function
input_dialogue = "Should we overwrite conf.py with the modified ast?\n\t[Y]/n\n"

def theme_update(theme_conf_path:pl.Path or str,
                 base_conf_path:pl.Path or str,
                 should_overwrite_conf_silently:bool=False,
                 force_display_diff_report:bool=None)->None:
    """Parses a theme's conf.py.sample file, along with the site's base conf.py file, and updates the base file
    according to the fields found in the theme.

    Uses libCST (https://github.com/Instagram/LibCST)

    Follows the visitor/transformer idiom described in libCST's documentation to programatically read and modify the
    site's conf.py file according to the contents of the theme's conf.py.sample file.

    Modifications are performed in memory, then a diff report is generated and

    :param theme_conf_path: Absolute path to where the theme's config file
    :param base_conf_path: Absolute path to where the site's base config file can be found
    :param should_overwrite_conf_silently: A diagnostic flag that specifies if we should
    :param force_display_diff_report: A bool flag specifying if we should force the display of the diff report between
                                      the base conf.py file and the code generated by the modified tree..
    :return: None
    """
    if isinstance(theme_conf_path,str):
        theme_conf_path = pl.Path(theme_conf_path).resolve()
    theme_name = theme_conf_path.parent.name
    # create the concrete syntax tree for the site's base conf.py file
    with open(base_conf_path,'r',encoding="UTF-8") as f:
        base_tree = cst.parse_module(f.read())
    # create the concrete syntax tree for the theme's conf.py.sample file
    with open(theme_conf_path, 'r', encoding="UTF-8") as f:
        theme_tree = cst.parse_module(f.read())
    # visitor will be used to create a mapping of the fields in the
    # theme config that should be modified in the base config.
    visitor = ThemeCollector(theme_name) # initializes the visitor
    # this is where the visitor traverses the theme tree and builds the member mapping.
    theme_tree.visit(visitor)
    # xfmr (shorthand for transformer) will take the mapping created by visitor
    # and apply changes to the base tree where it finds equivalent members/properties.
    xfmr = ThemeTransformer(visitor.replacement_targets)
    modified_base_tree = base_tree.visit(xfmr)
    # missed_nodes are the variables/functions/classes we found in the theme's conf.py.sample file that had no analogue
    # in the conf.py file. So, we'll just append them to the end of the conf.py file here.
    #   Note: It could be a problem if these missed nodes need to be inserted in the order the appeared in the theme's
    #         config file, as libcst is still developing the tools for inserting nodes relative to a line number.
    #         * A possible solution is to somehow record the order nodes are encountered in the visitor, and then record
    #           the line number (or something like it) of updated fields in the visitor, then we can insert nodes at the
    #           appropriate position in the modified_base_tree.body list.
    missed_nodes = xfmr.all_keys.difference(xfmr.utlized_keys)
    if missed_nodes:
        code_strings = [modified_base_tree.code]
        for missing_k in missed_nodes:
            node:cst.CSTNode = xfmr.replacement_targets[missing_k]
            # this simply appends the missed nodes to the modified_base_tree and reparses the resulting code string.
            code_strings.append(modified_base_tree.code_for_node(node))
        modified_base_tree = cst.parse_module("\n".join(code_strings))
    # libCST provides a built in recursive equality checking function, this lets us efficiently determine if the
    # modified_base_tree actually contains updates to the base_tree.
    if not modified_base_tree.deep_equals(base_tree):
        if force_display_diff_report or (force_display_diff_report is None and not should_overwrite_conf_silently):
            # for visual diagnostic inspection of the changes.
            diff = difflib.unified_diff(base_tree.code.splitlines(True),modified_base_tree.code.splitlines(True))
            print("".join(diff))
        if should_overwrite_conf_silently or input(input_dialogue).lower()=='y':
            with open(base_conf_path,'w',encoding="UTF-8") as f:
                f.write(modified_base_tree.code)
        else:
            # creates a new file in the same directory as the original conf.py file named 'modified_conf.py'
            with open(base_conf_path.parent.joinpath("modified_conf.py"),'w',encoding="UTF-8") as f:
                f.write(modified_base_tree.code)
    else:
        print(f"no changes made to conf.py"
              f"\nit's likely that `./themes/{theme_name}/conf.py.sample` was empty or contained only comments"
              "\n\tIt's also possible that the custom visitor/transformer classes need to be modified to capture the"
              "\n\tgrammar and syntax used in the theme's config file "
              "\n\t\t-- I didn't define things like class definitions and update-assignment operations in this example")


def example_start():
    safe_to_proceed = True
    base_conf_py_path = here.joinpath("some_site_structure/conf.py").resolve()
    if not base_conf_py_path.exists():
        safe_to_proceed = False
        print("The example `conf.py` file isn't where we expected it to be."
              "Please check the following path for where things might have gone wrong:"
              f"\n{str(base_conf_py_path)}"
              "\n\tThen modify the call to base_conf_py_path = here.joinpath('some_site_structure/conf.py').resolve()")
    theme_conf_py_path = here.joinpath("some_site_structure/themes/some_theme/conf.py.sample").resolve()
    if not theme_conf_py_path.exists():
        safe_to_proceed = False
        print("The example `conf.py` file isn't where we expected it to be."
              "Please check the following path for where things might have gone wrong:"
              f"\n{str(base_conf_py_path)}"
              "\n\tThen modify the call to theme_conf_py_path = here.joinpath('some_site_structure/themes/some_theme/conf.py.sample').resolve()")
    if safe_to_proceed:
        theme_update(theme_conf_py_path,
                     base_conf_py_path)
    else:
        print("Until the path to the example config files is resolved, we can't run the example")

if __name__ == "__main__":
    example_start()